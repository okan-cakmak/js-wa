(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["JetSocket"] = factory();
	else
		root["JetSocket"] = factory();
})(this, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/ws/browser.js":
/*!************************************!*\
  !*** ./node_modules/ws/browser.js ***!
  \************************************/
/***/ (function(module) {

"use strict";


module.exports = function () {
  throw new Error(
    'ws does not work in the browser. Browser clients must use the native ' +
      'WebSocket object'
  );
};


/***/ }),

/***/ "./src/JetSocket.js":
/*!**************************!*\
  !*** ./src/JetSocket.js ***!
  \**************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Use native WebSocket in browser, fallback to ws in Node.js
const WebSocketImpl = typeof WebSocket !== 'undefined' ? WebSocket : __webpack_require__(/*! ws */ "./node_modules/ws/browser.js");

class JetSocket {
    constructor(options) {
        this.version = '1.0.0'; // Library version
        this.protocol = 7; // Pusher protocol version

        // Connection states
        this.STATES = {
            INITIALIZED: 'initialized',
            CONNECTING: 'connecting',
            CONNECTED: 'connected',
            DISCONNECTING: 'disconnecting',
            DISCONNECTED: 'disconnected',
            RECONNECTING: 'reconnecting',
            FAILED: 'failed'
        };

        this.options = {
            appKey: options.appKey,
            cluster: options.cluster || 'mt1',
            encrypted: options.encrypted !== false,
            wsHost: options.wsHost || `ws-${options.cluster}.jetsocket.io`, // WebSocket host
            wsPort: options.wsPort || (options.encrypted ? 443 : 80), // Allow custom port
            activityTimeout: 120, // Default activity timeout in seconds
            pongTimeout: 30, // Time to wait for pong response
            maxReconnectionAttempts: 6,
            maxReconnectGap: 30000, // Maximum reconnection gap in ms
            minReconnectGap: 1000,  // Minimum reconnection gap in ms
            rateLimiter: {
                maxEventsPerSecond: 10,
                maxEventsInBurst: 100
            },
            ...options
        };

        this.state = {
            connectionState: this.STATES.INITIALIZED,
            socket: null,
            channels: new Map(),
            socketId: null,
            activityTimeout: this.options.activityTimeout,
            lastActivity: null,
            activityTimer: null,
            pongTimer: null,
            reconnectTimer: null,
            reconnectionAttempts: 0,
            userDisconnected: false, // Track if disconnect was user initiated
            eventCount: 0,
            eventTimestamps: [],
            lastEventTime: null
        };

        this.events = {
            state_change: new Set(),
            connection: new Set(),
            error: new Set(),
            disconnection: new Set()
        };

        // Error codes and messages
        this.ERROR_CODES = {
            // Transport level errors (4000-4099)
            4000: 'Application only accepts SSL connections',
            4001: 'Application does not exist',
            4002: 'Application disabled',
            4003: 'Application rate limited',
            4004: 'Path not found',
            4005: 'Invalid version string format',
            4006: 'Invalid version',
            4007: 'Unsupported protocol version',
            4008: 'No protocol version supplied',
            4009: 'Connection is unauthorized',
            
            // Application level errors (4100-4199)
            4100: 'Over connection limit',
            4101: 'Over connection limit for application',
            4102: 'Path already in use',
            4103: 'Client event rejected - rate limit exceeded',
            4104: 'Client event rejected - invalid data format',
            4105: 'Client event rejected - event name too long',
            4106: 'Client event rejected - event data too large',
            4107: 'Client event rejected - event name format invalid',
            
            // Channel level errors (4200-4299)
            4200: 'Generic subscription error',
            4201: 'Not authorized to subscribe',
            4202: 'Subscription rejected - rate limit exceeded',
            4203: 'Subscription rejected - invalid channel name',
            4204: 'Subscription rejected - channel already subscribed',
            4205: 'Subscription rejected - channel capacity reached',
            4206: 'Subscription rejected - presence channel limit reached',
            4207: 'Subscription rejected - presence channel user limit reached'
        };

        this.connect();
    }

    // Update connection state and emit state change event
    updateState(newState, data = {}) {
        const previousState = this.state.connectionState;
        this.state.connectionState = newState;
        
        this.emit('state_change', {
            previous: previousState,
            current: newState,
            ...data
        });
    }

    connect() {
        // Don't reconnect if explicitly disconnected by user
        if (this.state.userDisconnected) {
            return;
        }

        this.updateState(this.STATES.CONNECTING);

        const protocol = this.options.encrypted ? 'wss://' : 'ws://';
        const queryParams = new URLSearchParams({
            protocol: this.protocol,
            client: 'js',
            version: this.version
        }).toString();

        // Format: {protocol}{host}/app/{key}?{query}
        const url = `${protocol}${this.options.wsHost}/app/${this.options.appKey}?${queryParams}`;

        try {
            this.state.socket = new WebSocketImpl(url);
            this.bindSocketEvents();
        } catch (error) {
            this.handleError({
                type: 'WebSocketError',
                error: error,
                data: { url }
            });
        }
    }

    handleError(error) {
        let errorData = {
            type: error.type || 'Error',
            code: error.code,
            message: error.message || 'Unknown error'
        };

        // Add human-readable message for known error codes
        if (error.code && this.ERROR_CODES[error.code]) {
            errorData.description = this.ERROR_CODES[error.code];
        }

        // Add additional context
        if (error.data) {
            errorData.data = error.data;
        }

        this.emit('error', errorData);
        
        // Handle fatal errors
        if (error.type === 'WebSocketError' || error.type === 'ConnectionError') {
            this.updateState(this.STATES.FAILED, { error: errorData });
            this.scheduleReconnection();
        }

        // Handle subscription errors
        if (error.type === 'SubscriptionError' && error.channel) {
            const channel = this.state.channels.get(error.channel);
            if (channel) {
                channel.handleSubscriptionError(error);
            }
        }
    }

    scheduleReconnection() {
        // Clear any existing reconnection timer
        if (this.state.reconnectTimer) {
            clearTimeout(this.state.reconnectTimer);
        }

        // Don't reconnect if max attempts reached or user disconnected
        if (this.state.userDisconnected || 
            this.state.reconnectionAttempts >= this.options.maxReconnectionAttempts) {
            this.updateState(this.STATES.FAILED);
            return;
        }

        // Calculate backoff delay with exponential backoff
        const delay = Math.min(
            this.options.maxReconnectGap,
            Math.max(
                this.options.minReconnectGap,
                Math.pow(2, this.state.reconnectionAttempts) * 1000
            )
        );

        this.updateState(this.STATES.RECONNECTING, {
            attempt: this.state.reconnectionAttempts + 1,
            delay
        });

        this.state.reconnectTimer = setTimeout(() => {
            this.state.reconnectionAttempts++;
            this.connect();
        }, delay);
    }

    bindSocketEvents() {
        this.state.socket.onopen = () => {
            // Reset reconnection attempts on successful connection
            this.state.reconnectionAttempts = 0;
            // Don't emit connection yet - wait for pusher:connection_established
        };

        this.state.socket.onclose = (closeEvent) => {
            this.cleanup();
            this.emit('disconnection', closeEvent);
            
            if (!this.state.userDisconnected) {
                this.scheduleReconnection();
            } else {
                this.updateState(this.STATES.DISCONNECTED);
            }
        };

        this.state.socket.onerror = (error) => {
            this.handleError(error);
        };

        this.state.socket.onmessage = (rawEvent) => {
            try {
                // Parse the main message
                const event = typeof rawEvent.data === 'string' ? 
                    JSON.parse(rawEvent.data) : 
                    rawEvent.data;

                this.handleEvent(event);
            } catch (error) {
                console.error("[WebSocket] Parse error:", error);
                this.emit('error', {
                    type: 'MessageParseError',
                    error: error,
                    data: rawEvent.data
                });
            }
        };
    }

    handleEvent(event) {
        console.log("[handleEvent] Processing event:", event.event);
        
        // Reset activity timer on any message received
        this.resetActivityTimer();
        
        switch (event.event) {
            case 'pusher:connection_established':
                try {
                    const data = typeof event.data === 'string' ? 
                        JSON.parse(event.data) : 
                        event.data;
                    
                    this.state.socketId = data.socket_id;
                    // Use server provided activity timeout if available
                    this.state.activityTimeout = data.activity_timeout || this.options.activityTimeout;
                    this.state.connected = true;
                    this.startActivityTimer();
                    this.emit('connection', { socketId: this.state.socketId });

                    // Use queueMicrotask to ensure any pending subscriptions are processed first
                    queueMicrotask(() => {
                        // Resubscribe to channels that were previously subscribed
                        this.state.channels.forEach((channel, channelName) => {
                            if (!channel.subscribed && !channel.subscribing) {
                                console.log("sending resubscription to channel", channelName);
                                try {
                                    channel.subscribing = true;  // Mark channel as being subscribed
                                    this.sendSubscription(channelName);
                                } catch (error) {
                                    channel.subscribing = false;  // Reset on error
                                    console.error(`[connection_established] Failed to subscribe to channel ${channelName}:`, error);
                                    this.emit('error', {
                                        type: 'SubscriptionError',
                                        error: error,
                                        channel: channelName
                                    });
                                }
                            }
                        });
                    });
                } catch (error) {
                    console.error("[connection_established] Parse error:", error);
                    this.emit('error', {
                        type: 'ConnectionError',
                        error: error,
                        data: event.data
                    });
                }
                break;

            case 'pusher:ping':
                this.send('pusher:pong', {});
                break;

            case 'pusher:error':
                // Handle both string and object data formats
                const errorData = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
                this.emit('error', errorData);
                break;

            case 'pusher_internal:subscription_succeeded':
                if (event.channel) {
                    console.log("[subscription_succeeded] Channel:", event.channel);
                    
                    const channel = this.state.channels.get(event.channel);
                    if (channel && !channel.subscribed) {
                        try {
                            let subscriptionData = {};
                            if (event.data && event.data !== '{}') {
                                subscriptionData = typeof event.data === 'string' ? 
                                    JSON.parse(event.data) : event.data;
                            }
                            channel.handleSubscriptionSucceeded(subscriptionData);
                        } catch (error) {
                            console.error("[subscription_succeeded] Parse error:", error);
                            this.emit('error', {
                                type: 'SubscriptionError',
                                error: error,
                                channel: event.channel
                            });
                        }
                    }
                }
                break;

            case 'pusher:pong':
                if (this.state.pongTimer) {
                    clearTimeout(this.state.pongTimer);
                    this.state.pongTimer = null;
                }
                break;

            default:
                // Handle channel events
                if (event.channel) {
                    const channel = this.state.channels.get(event.channel);
                    if (channel) {
                        // For non-pusher events, pass the data as-is without forcing JSON parse
                        // Only parse if it's a pusher event
                        const eventData = event.event.startsWith('pusher:') && typeof event.data === 'string' ? 
                            (event.data ? JSON.parse(event.data) : null) : 
                            event.data;
                        channel.handleEvent({
                            ...event,
                            data: eventData
                        });
                    }
                }
        }
    }

    sendSubscription(channelName) {
        console.log(Date.now(), " sending subscription to channel", channelName);
        const subscriptionData = {
            channel: channelName
        };

        // Add auth data only for private/presence channels
        if (channelName.startsWith('private-') || channelName.startsWith('presence-')) {
            if (!this.options.auth || !this.options.auth.endpoint) {
                throw new Error('Authentication endpoint required for private/presence channels');
            }

            const authData = {
                socket_id: this.state.socketId,
                channel_name: channelName
            };

            // Make HTTP request to auth endpoint
            return fetch(this.options.auth.endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    ...(this.options.auth.headers || {})
                },
                body: JSON.stringify(authData)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Auth endpoint returned ${response.status}`);
                }
                return response.json();
            })
            .then(authResponse => {
                if (!authResponse.auth) {
                    throw new Error('Auth endpoint did not return auth signature');
                }
                
                // Add the auth signature to subscription data
                subscriptionData.auth = authResponse.auth;
                
                // Add any channel data for presence channels
                if (authResponse.channel_data) {
                    subscriptionData.channel_data = authResponse.channel_data;
                }
                
                this.send('pusher:subscribe', subscriptionData);
            })
            .catch(error => {
                const channel = this.state.channels.get(channelName);
                if (channel) {
                    channel.subscribing = false;
                }
                this.emit('error', {
                    type: 'AuthError',
                    error: error,
                    channel: channelName
                });
            });
        }

        // For public channels, send subscription immediately
        this.send('pusher:subscribe', subscriptionData);
    }

    subscribe(channelName) {
        console.log(Date.now(), " subscribing to channel", channelName);
        const existingChannel = this.state.channels.get(channelName);
        
        // Return existing channel if already subscribed or in process of subscribing
        if (existingChannel && (existingChannel.subscribed || existingChannel.subscribing)) {
            return existingChannel;
        }

        // Create new channel if it doesn't exist
        if (!existingChannel) {
            const channel = new Channel(channelName, this);
            this.state.channels.set(channelName, channel);
        }

        // Send subscription if connected
        if (this.state.connected) {
            const channel = this.state.channels.get(channelName);
            channel.subscribing = true;
            this.sendSubscription(channelName);
        }
        
        return this.state.channels.get(channelName);
    }

    unsubscribe(channelName) {
        const channel = this.state.channels.get(channelName);
        if (channel) {
            this.send('pusher:unsubscribe', {
                channel: channelName
            });
            channel.subscribed = false;
            this.state.channels.delete(channelName);
        }
    }

    send(event, data, channel = null) {
        // Validate event name length
        if (event.length > 200) {
            throw new Error('Event name too long');
        }

        // Validate data size (max 10KB)
        const dataSize = JSON.stringify(data).length;
        if (dataSize > 10240) {
            throw new Error('Event data too large');
        }

        // Apply rate limiting for client events
        if (event.startsWith('client-')) {
            try {
                this.checkRateLimit();
            } catch (error) {
                this.handleError({
                    type: 'RateLimitError',
                    code: 4103,
                    message: error.message
                });
                return;
            }
        }

        const message = {
            event: event,
            data: event.startsWith('pusher:') ? data : JSON.stringify(data)
        };
        
        if (channel) {
            message.channel = channel;
        }

        if (this.state.socket && this.state.socket.readyState === WebSocketImpl.OPEN) {
            try {
                this.state.socket.send(JSON.stringify(message));
            } catch (error) {
                this.handleError({
                    type: 'SendError',
                    message: 'Failed to send message',
                    data: { event, channel }
                });
            }
        }
    }

    startActivityTimer() {
        this.resetActivityTimer();
        
        // Start monitoring for activity
        this.state.activityTimer = setInterval(() => {
            const now = Date.now();
            if (!this.state.lastActivity || (now - this.state.lastActivity) >= (this.state.activityTimeout * 1000)) {
                this.ping();
            }
        }, 1000); // Check every second
    }

    resetActivityTimer() {
        this.state.lastActivity = Date.now();
    }

    ping() {
        if (!this.state.connected) return;

        this.send('pusher:ping', {});
        
        // Start pong timeout
        if (this.state.pongTimer) {
            clearTimeout(this.state.pongTimer);
        }
        
        this.state.pongTimer = setTimeout(() => {
            console.log('No pong received within timeout, closing connection');
            this.disconnect();
        }, this.options.pongTimeout * 1000);
    }

    cleanup() {
        if (this.state.activityTimer) {
            clearInterval(this.state.activityTimer);
            this.state.activityTimer = null;
        }
        if (this.state.pongTimer) {
            clearTimeout(this.state.pongTimer);
            this.state.pongTimer = null;
        }
        if (this.state.reconnectTimer) {
            clearTimeout(this.state.reconnectTimer);
            this.state.reconnectTimer = null;
        }
        
        // Mark all channels as unsubscribed on cleanup
        this.state.channels.forEach(channel => {
            channel.subscribed = false;
        });
        
        this.state.socketId = null;
        this.state.lastActivity = null;
    }

    disconnect() {
        this.state.userDisconnected = true;
        this.updateState(this.STATES.DISCONNECTING);
        
        if (this.state.reconnectTimer) {
            clearTimeout(this.state.reconnectTimer);
            this.state.reconnectTimer = null;
        }

        if (this.state.socket) {
            this.state.socket.close();
        }
        this.cleanup();
        this.updateState(this.STATES.DISCONNECTED);
    }

    on(event, callback) {
        if (this.events[event]) {
            this.events[event].add(callback);
        }
    }

    off(event, callback) {
        if (this.events[event]) {
            this.events[event].delete(callback);
        }
    }

    emit(event, data) {
        if (this.events[event]) {
            this.events[event].forEach(callback => callback(data));
        }
    }

    // Rate limiting implementation
    checkRateLimit() {
        const now = Date.now();
        const oneSecondAgo = now - 1000;
        
        // Remove events older than 1 second
        this.state.eventTimestamps = this.state.eventTimestamps.filter(
            timestamp => timestamp > oneSecondAgo
        );

        // Check rate limits
        if (this.state.eventTimestamps.length >= this.options.rateLimiter.maxEventsInBurst) {
            throw new Error('Rate limit exceeded: Too many events in burst');
        }

        const eventsInLastSecond = this.state.eventTimestamps.length;
        if (eventsInLastSecond >= this.options.rateLimiter.maxEventsPerSecond) {
            throw new Error('Rate limit exceeded: Too many events per second');
        }

        // Record this event
        this.state.eventTimestamps.push(now);
        this.state.lastEventTime = now;
    }
}

class Channel {
    constructor(name, client) {
        this.name = name;
        this.client = client;
        this.events = new Map();
        this.subscribed = false;
        this.subscribing = false;
        
        // Presence channel specific properties
        this.members = new Map();
        this.myID = null;
        this.me = null;
        this.subscriptionPending = true;
        
        // Determine channel type
        this.type = this.getChannelType();
    }

    getChannelType() {
        if (this.name.startsWith('private-')) {
            return 'private';
        } else if (this.name.startsWith('presence-')) {
            return 'presence';
        }
        return 'public';
    }

    bind(eventName, callback) {
        if (!this.events.has(eventName)) {
            this.events.set(eventName, new Set());
        }
        this.events.get(eventName).add(callback);
    }

    unbind(eventName, callback) {
        if (this.events.has(eventName)) {
            if (callback) {
                this.events.get(eventName).delete(callback);
            } else {
                this.events.delete(eventName);
            }
        }
    }

    handleEvent(event) {
        console.log("[Channel handleEvent] Event:", event);
        
        // Handle presence channel specific events
        if (this.type === 'presence') {
            switch (event.event) {
                case 'pusher_internal:member_added':
                    if (event.data) {
                        const memberData = typeof event.data === 'string' ? 
                            JSON.parse(event.data) : event.data;
                        this.members.set(memberData.user_id, memberData.user_info);
                        this.emit('pusher:member_added', {
                            id: memberData.user_id,
                            info: memberData.user_info
                        });
                    }
                    return;

                case 'pusher_internal:member_removed':
                    if (event.data) {
                        const memberData = typeof event.data === 'string' ? 
                            JSON.parse(event.data) : event.data;
                        const member = this.members.get(memberData.user_id);
                        this.members.delete(memberData.user_id);
                        if (member) {
                            this.emit('pusher:member_removed', {
                                id: memberData.user_id,
                                info: member
                            });
                        }
                    }
                    return;
            }
        }

        // Handle regular events
        if (this.events.has(event.event)) {
            const callbacks = this.events.get(event.event);
            try {
                const data = event.event.startsWith('pusher:') && typeof event.data === 'string' ? 
                    JSON.parse(event.data) : 
                    event.data;
                callbacks.forEach(callback => callback(data));
            } catch (error) {
                console.error("[Channel handleEvent] Parse error:", error);
                throw error;
            }
        }
    }

    handleSubscriptionSucceeded(data) {
        this.subscribed = true;
        this.subscribing = false;
        this.subscriptionPending = false;

        // Handle presence channel subscription data
        if (this.type === 'presence' && data) {
            // Initialize presence state
            this.myID = data.myID;
            this.me = data.me;
            
            // Set initial members
            if (data.presence && data.presence.members) {
                Object.entries(data.presence.members).forEach(([id, info]) => {
                    this.members.set(id, info);
                });
            }
        }

        // Emit subscription succeeded event
        if (this.events.has('pusher:subscription_succeeded')) {
            const callbacks = this.events.get('pusher:subscription_succeeded');
            callbacks.forEach(callback => callback(data));
        }
    }

    handleSubscriptionError(error) {
        this.subscribed = false;
        this.subscribing = false;
        this.subscriptionPending = false;
        
        if (this.events.has('pusher:subscription_error')) {
            this.emit('pusher:subscription_error', error);
        }
    }

    // Presence channel specific methods
    members() {
        if (this.type !== 'presence') {
            throw new Error('Members can only be accessed on presence channels');
        }
        return Array.from(this.members.entries()).map(([id, info]) => ({
            id,
            info
        }));
    }

    myMember() {
        if (this.type !== 'presence') {
            throw new Error('Member info can only be accessed on presence channels');
        }
        return this.me ? { id: this.myID, info: this.me } : null;
    }

    emit(eventName, data) {
        if (this.events.has(eventName)) {
            const callbacks = this.events.get(eventName);
            callbacks.forEach(callback => callback(data));
        }
    }

    trigger(eventName, data) {
        if (!this.name.startsWith('private-') && !this.name.startsWith('presence-')) {
            throw new Error('Client events can only be triggered on private or presence channels');
        }

        if (!eventName.startsWith('client-')) {
            throw new Error('Client events must be prefixed with client-');
        }

        // Validate event name format
        if (!/^client-[a-zA-Z0-9-_]+$/.test(eventName)) {
            throw new Error('Invalid event name format');
        }

        this.client.send(eventName, data, this.name);
    }
}

// Export for both browser and Node.js environments
if ( true && module.exports) {
    module.exports = JetSocket;
} else if (typeof window !== 'undefined') {
    window.JetSocket = JetSocket;
} 

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/JetSocket.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrQkFBK0I7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQTZCO0FBQ2pDO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7Ozs7OztVQ2x5QkE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7OztVRXRCQTtVQUNBO1VBQ0E7VUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0pldFNvY2tldC93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vSmV0U29ja2V0Ly4vbm9kZV9tb2R1bGVzL3dzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vSmV0U29ja2V0Ly4vc3JjL0pldFNvY2tldC5qcyIsIndlYnBhY2s6Ly9KZXRTb2NrZXQvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vSmV0U29ja2V0L3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vSmV0U29ja2V0L3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9KZXRTb2NrZXQvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkpldFNvY2tldFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJKZXRTb2NrZXRcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3dzIGRvZXMgbm90IHdvcmsgaW4gdGhlIGJyb3dzZXIuIEJyb3dzZXIgY2xpZW50cyBtdXN0IHVzZSB0aGUgbmF0aXZlICcgK1xuICAgICAgJ1dlYlNvY2tldCBvYmplY3QnXG4gICk7XG59O1xuIiwiLy8gVXNlIG5hdGl2ZSBXZWJTb2NrZXQgaW4gYnJvd3NlciwgZmFsbGJhY2sgdG8gd3MgaW4gTm9kZS5qc1xuY29uc3QgV2ViU29ja2V0SW1wbCA9IHR5cGVvZiBXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnID8gV2ViU29ja2V0IDogcmVxdWlyZSgnd3MnKTtcblxuY2xhc3MgSmV0U29ja2V0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9ICcxLjAuMCc7IC8vIExpYnJhcnkgdmVyc2lvblxuICAgICAgICB0aGlzLnByb3RvY29sID0gNzsgLy8gUHVzaGVyIHByb3RvY29sIHZlcnNpb25cblxuICAgICAgICAvLyBDb25uZWN0aW9uIHN0YXRlc1xuICAgICAgICB0aGlzLlNUQVRFUyA9IHtcbiAgICAgICAgICAgIElOSVRJQUxJWkVEOiAnaW5pdGlhbGl6ZWQnLFxuICAgICAgICAgICAgQ09OTkVDVElORzogJ2Nvbm5lY3RpbmcnLFxuICAgICAgICAgICAgQ09OTkVDVEVEOiAnY29ubmVjdGVkJyxcbiAgICAgICAgICAgIERJU0NPTk5FQ1RJTkc6ICdkaXNjb25uZWN0aW5nJyxcbiAgICAgICAgICAgIERJU0NPTk5FQ1RFRDogJ2Rpc2Nvbm5lY3RlZCcsXG4gICAgICAgICAgICBSRUNPTk5FQ1RJTkc6ICdyZWNvbm5lY3RpbmcnLFxuICAgICAgICAgICAgRkFJTEVEOiAnZmFpbGVkJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFwcEtleTogb3B0aW9ucy5hcHBLZXksXG4gICAgICAgICAgICBjbHVzdGVyOiBvcHRpb25zLmNsdXN0ZXIgfHwgJ210MScsXG4gICAgICAgICAgICBlbmNyeXB0ZWQ6IG9wdGlvbnMuZW5jcnlwdGVkICE9PSBmYWxzZSxcbiAgICAgICAgICAgIHdzSG9zdDogb3B0aW9ucy53c0hvc3QgfHwgYHdzLSR7b3B0aW9ucy5jbHVzdGVyfS5qZXRzb2NrZXQuaW9gLCAvLyBXZWJTb2NrZXQgaG9zdFxuICAgICAgICAgICAgd3NQb3J0OiBvcHRpb25zLndzUG9ydCB8fCAob3B0aW9ucy5lbmNyeXB0ZWQgPyA0NDMgOiA4MCksIC8vIEFsbG93IGN1c3RvbSBwb3J0XG4gICAgICAgICAgICBhY3Rpdml0eVRpbWVvdXQ6IDEyMCwgLy8gRGVmYXVsdCBhY3Rpdml0eSB0aW1lb3V0IGluIHNlY29uZHNcbiAgICAgICAgICAgIHBvbmdUaW1lb3V0OiAzMCwgLy8gVGltZSB0byB3YWl0IGZvciBwb25nIHJlc3BvbnNlXG4gICAgICAgICAgICBtYXhSZWNvbm5lY3Rpb25BdHRlbXB0czogNixcbiAgICAgICAgICAgIG1heFJlY29ubmVjdEdhcDogMzAwMDAsIC8vIE1heGltdW0gcmVjb25uZWN0aW9uIGdhcCBpbiBtc1xuICAgICAgICAgICAgbWluUmVjb25uZWN0R2FwOiAxMDAwLCAgLy8gTWluaW11bSByZWNvbm5lY3Rpb24gZ2FwIGluIG1zXG4gICAgICAgICAgICByYXRlTGltaXRlcjoge1xuICAgICAgICAgICAgICAgIG1heEV2ZW50c1BlclNlY29uZDogMTAsXG4gICAgICAgICAgICAgICAgbWF4RXZlbnRzSW5CdXJzdDogMTAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uU3RhdGU6IHRoaXMuU1RBVEVTLklOSVRJQUxJWkVELFxuICAgICAgICAgICAgc29ja2V0OiBudWxsLFxuICAgICAgICAgICAgY2hhbm5lbHM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIHNvY2tldElkOiBudWxsLFxuICAgICAgICAgICAgYWN0aXZpdHlUaW1lb3V0OiB0aGlzLm9wdGlvbnMuYWN0aXZpdHlUaW1lb3V0LFxuICAgICAgICAgICAgbGFzdEFjdGl2aXR5OiBudWxsLFxuICAgICAgICAgICAgYWN0aXZpdHlUaW1lcjogbnVsbCxcbiAgICAgICAgICAgIHBvbmdUaW1lcjogbnVsbCxcbiAgICAgICAgICAgIHJlY29ubmVjdFRpbWVyOiBudWxsLFxuICAgICAgICAgICAgcmVjb25uZWN0aW9uQXR0ZW1wdHM6IDAsXG4gICAgICAgICAgICB1c2VyRGlzY29ubmVjdGVkOiBmYWxzZSwgLy8gVHJhY2sgaWYgZGlzY29ubmVjdCB3YXMgdXNlciBpbml0aWF0ZWRcbiAgICAgICAgICAgIGV2ZW50Q291bnQ6IDAsXG4gICAgICAgICAgICBldmVudFRpbWVzdGFtcHM6IFtdLFxuICAgICAgICAgICAgbGFzdEV2ZW50VGltZTogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZXZlbnRzID0ge1xuICAgICAgICAgICAgc3RhdGVfY2hhbmdlOiBuZXcgU2V0KCksXG4gICAgICAgICAgICBjb25uZWN0aW9uOiBuZXcgU2V0KCksXG4gICAgICAgICAgICBlcnJvcjogbmV3IFNldCgpLFxuICAgICAgICAgICAgZGlzY29ubmVjdGlvbjogbmV3IFNldCgpXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRXJyb3IgY29kZXMgYW5kIG1lc3NhZ2VzXG4gICAgICAgIHRoaXMuRVJST1JfQ09ERVMgPSB7XG4gICAgICAgICAgICAvLyBUcmFuc3BvcnQgbGV2ZWwgZXJyb3JzICg0MDAwLTQwOTkpXG4gICAgICAgICAgICA0MDAwOiAnQXBwbGljYXRpb24gb25seSBhY2NlcHRzIFNTTCBjb25uZWN0aW9ucycsXG4gICAgICAgICAgICA0MDAxOiAnQXBwbGljYXRpb24gZG9lcyBub3QgZXhpc3QnLFxuICAgICAgICAgICAgNDAwMjogJ0FwcGxpY2F0aW9uIGRpc2FibGVkJyxcbiAgICAgICAgICAgIDQwMDM6ICdBcHBsaWNhdGlvbiByYXRlIGxpbWl0ZWQnLFxuICAgICAgICAgICAgNDAwNDogJ1BhdGggbm90IGZvdW5kJyxcbiAgICAgICAgICAgIDQwMDU6ICdJbnZhbGlkIHZlcnNpb24gc3RyaW5nIGZvcm1hdCcsXG4gICAgICAgICAgICA0MDA2OiAnSW52YWxpZCB2ZXJzaW9uJyxcbiAgICAgICAgICAgIDQwMDc6ICdVbnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uJyxcbiAgICAgICAgICAgIDQwMDg6ICdObyBwcm90b2NvbCB2ZXJzaW9uIHN1cHBsaWVkJyxcbiAgICAgICAgICAgIDQwMDk6ICdDb25uZWN0aW9uIGlzIHVuYXV0aG9yaXplZCcsXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFwcGxpY2F0aW9uIGxldmVsIGVycm9ycyAoNDEwMC00MTk5KVxuICAgICAgICAgICAgNDEwMDogJ092ZXIgY29ubmVjdGlvbiBsaW1pdCcsXG4gICAgICAgICAgICA0MTAxOiAnT3ZlciBjb25uZWN0aW9uIGxpbWl0IGZvciBhcHBsaWNhdGlvbicsXG4gICAgICAgICAgICA0MTAyOiAnUGF0aCBhbHJlYWR5IGluIHVzZScsXG4gICAgICAgICAgICA0MTAzOiAnQ2xpZW50IGV2ZW50IHJlamVjdGVkIC0gcmF0ZSBsaW1pdCBleGNlZWRlZCcsXG4gICAgICAgICAgICA0MTA0OiAnQ2xpZW50IGV2ZW50IHJlamVjdGVkIC0gaW52YWxpZCBkYXRhIGZvcm1hdCcsXG4gICAgICAgICAgICA0MTA1OiAnQ2xpZW50IGV2ZW50IHJlamVjdGVkIC0gZXZlbnQgbmFtZSB0b28gbG9uZycsXG4gICAgICAgICAgICA0MTA2OiAnQ2xpZW50IGV2ZW50IHJlamVjdGVkIC0gZXZlbnQgZGF0YSB0b28gbGFyZ2UnLFxuICAgICAgICAgICAgNDEwNzogJ0NsaWVudCBldmVudCByZWplY3RlZCAtIGV2ZW50IG5hbWUgZm9ybWF0IGludmFsaWQnLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDaGFubmVsIGxldmVsIGVycm9ycyAoNDIwMC00Mjk5KVxuICAgICAgICAgICAgNDIwMDogJ0dlbmVyaWMgc3Vic2NyaXB0aW9uIGVycm9yJyxcbiAgICAgICAgICAgIDQyMDE6ICdOb3QgYXV0aG9yaXplZCB0byBzdWJzY3JpYmUnLFxuICAgICAgICAgICAgNDIwMjogJ1N1YnNjcmlwdGlvbiByZWplY3RlZCAtIHJhdGUgbGltaXQgZXhjZWVkZWQnLFxuICAgICAgICAgICAgNDIwMzogJ1N1YnNjcmlwdGlvbiByZWplY3RlZCAtIGludmFsaWQgY2hhbm5lbCBuYW1lJyxcbiAgICAgICAgICAgIDQyMDQ6ICdTdWJzY3JpcHRpb24gcmVqZWN0ZWQgLSBjaGFubmVsIGFscmVhZHkgc3Vic2NyaWJlZCcsXG4gICAgICAgICAgICA0MjA1OiAnU3Vic2NyaXB0aW9uIHJlamVjdGVkIC0gY2hhbm5lbCBjYXBhY2l0eSByZWFjaGVkJyxcbiAgICAgICAgICAgIDQyMDY6ICdTdWJzY3JpcHRpb24gcmVqZWN0ZWQgLSBwcmVzZW5jZSBjaGFubmVsIGxpbWl0IHJlYWNoZWQnLFxuICAgICAgICAgICAgNDIwNzogJ1N1YnNjcmlwdGlvbiByZWplY3RlZCAtIHByZXNlbmNlIGNoYW5uZWwgdXNlciBsaW1pdCByZWFjaGVkJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBjb25uZWN0aW9uIHN0YXRlIGFuZCBlbWl0IHN0YXRlIGNoYW5nZSBldmVudFxuICAgIHVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBkYXRhID0ge30pIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RhdGUuY29ubmVjdGlvblN0YXRlO1xuICAgICAgICB0aGlzLnN0YXRlLmNvbm5lY3Rpb25TdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5lbWl0KCdzdGF0ZV9jaGFuZ2UnLCB7XG4gICAgICAgICAgICBwcmV2aW91czogcHJldmlvdXNTdGF0ZSxcbiAgICAgICAgICAgIGN1cnJlbnQ6IG5ld1N0YXRlLFxuICAgICAgICAgICAgLi4uZGF0YVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25uZWN0KCkge1xuICAgICAgICAvLyBEb24ndCByZWNvbm5lY3QgaWYgZXhwbGljaXRseSBkaXNjb25uZWN0ZWQgYnkgdXNlclxuICAgICAgICBpZiAodGhpcy5zdGF0ZS51c2VyRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHRoaXMuU1RBVEVTLkNPTk5FQ1RJTkcpO1xuXG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gdGhpcy5vcHRpb25zLmVuY3J5cHRlZCA/ICd3c3M6Ly8nIDogJ3dzOi8vJztcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIHByb3RvY29sOiB0aGlzLnByb3RvY29sLFxuICAgICAgICAgICAgY2xpZW50OiAnanMnLFxuICAgICAgICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uXG4gICAgICAgIH0pLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgLy8gRm9ybWF0OiB7cHJvdG9jb2x9e2hvc3R9L2FwcC97a2V5fT97cXVlcnl9XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3Byb3RvY29sfSR7dGhpcy5vcHRpb25zLndzSG9zdH0vYXBwLyR7dGhpcy5vcHRpb25zLmFwcEtleX0/JHtxdWVyeVBhcmFtc31gO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNvY2tldCA9IG5ldyBXZWJTb2NrZXRJbXBsKHVybCk7XG4gICAgICAgICAgICB0aGlzLmJpbmRTb2NrZXRFdmVudHMoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdXZWJTb2NrZXRFcnJvcicsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIGRhdGE6IHsgdXJsIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgbGV0IGVycm9yRGF0YSA9IHtcbiAgICAgICAgICAgIHR5cGU6IGVycm9yLnR5cGUgfHwgJ0Vycm9yJyxcbiAgICAgICAgICAgIGNvZGU6IGVycm9yLmNvZGUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFkZCBodW1hbi1yZWFkYWJsZSBtZXNzYWdlIGZvciBrbm93biBlcnJvciBjb2Rlc1xuICAgICAgICBpZiAoZXJyb3IuY29kZSAmJiB0aGlzLkVSUk9SX0NPREVTW2Vycm9yLmNvZGVdKSB7XG4gICAgICAgICAgICBlcnJvckRhdGEuZGVzY3JpcHRpb24gPSB0aGlzLkVSUk9SX0NPREVTW2Vycm9yLmNvZGVdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGFkZGl0aW9uYWwgY29udGV4dFxuICAgICAgICBpZiAoZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgZXJyb3JEYXRhLmRhdGEgPSBlcnJvci5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yRGF0YSk7XG4gICAgICAgIFxuICAgICAgICAvLyBIYW5kbGUgZmF0YWwgZXJyb3JzXG4gICAgICAgIGlmIChlcnJvci50eXBlID09PSAnV2ViU29ja2V0RXJyb3InIHx8IGVycm9yLnR5cGUgPT09ICdDb25uZWN0aW9uRXJyb3InKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHRoaXMuU1RBVEVTLkZBSUxFRCwgeyBlcnJvcjogZXJyb3JEYXRhIH0pO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlY29ubmVjdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIHN1YnNjcmlwdGlvbiBlcnJvcnNcbiAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09ICdTdWJzY3JpcHRpb25FcnJvcicgJiYgZXJyb3IuY2hhbm5lbCkge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuc3RhdGUuY2hhbm5lbHMuZ2V0KGVycm9yLmNoYW5uZWwpO1xuICAgICAgICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmhhbmRsZVN1YnNjcmlwdGlvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNjaGVkdWxlUmVjb25uZWN0aW9uKCkge1xuICAgICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgcmVjb25uZWN0aW9uIHRpbWVyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnJlY29ubmVjdFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zdGF0ZS5yZWNvbm5lY3RUaW1lcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb24ndCByZWNvbm5lY3QgaWYgbWF4IGF0dGVtcHRzIHJlYWNoZWQgb3IgdXNlciBkaXNjb25uZWN0ZWRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudXNlckRpc2Nvbm5lY3RlZCB8fCBcbiAgICAgICAgICAgIHRoaXMuc3RhdGUucmVjb25uZWN0aW9uQXR0ZW1wdHMgPj0gdGhpcy5vcHRpb25zLm1heFJlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHRoaXMuU1RBVEVTLkZBSUxFRCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgYmFja29mZiBkZWxheSB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgY29uc3QgZGVsYXkgPSBNYXRoLm1pbihcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tYXhSZWNvbm5lY3RHYXAsXG4gICAgICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubWluUmVjb25uZWN0R2FwLFxuICAgICAgICAgICAgICAgIE1hdGgucG93KDIsIHRoaXMuc3RhdGUucmVjb25uZWN0aW9uQXR0ZW1wdHMpICogMTAwMFxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUodGhpcy5TVEFURVMuUkVDT05ORUNUSU5HLCB7XG4gICAgICAgICAgICBhdHRlbXB0OiB0aGlzLnN0YXRlLnJlY29ubmVjdGlvbkF0dGVtcHRzICsgMSxcbiAgICAgICAgICAgIGRlbGF5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc3RhdGUucmVjb25uZWN0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUucmVjb25uZWN0aW9uQXR0ZW1wdHMrKztcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgfVxuXG4gICAgYmluZFNvY2tldEV2ZW50cygpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zb2NrZXQub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gUmVzZXQgcmVjb25uZWN0aW9uIGF0dGVtcHRzIG9uIHN1Y2Nlc3NmdWwgY29ubmVjdGlvblxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IDA7XG4gICAgICAgICAgICAvLyBEb24ndCBlbWl0IGNvbm5lY3Rpb24geWV0IC0gd2FpdCBmb3IgcHVzaGVyOmNvbm5lY3Rpb25fZXN0YWJsaXNoZWRcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnN0YXRlLnNvY2tldC5vbmNsb3NlID0gKGNsb3NlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdkaXNjb25uZWN0aW9uJywgY2xvc2VFdmVudCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS51c2VyRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlY29ubmVjdGlvbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHRoaXMuU1RBVEVTLkRJU0NPTk5FQ1RFRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zdGF0ZS5zb2NrZXQub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zdGF0ZS5zb2NrZXQub25tZXNzYWdlID0gKHJhd0V2ZW50KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBtYWluIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHR5cGVvZiByYXdFdmVudC5kYXRhID09PSAnc3RyaW5nJyA/IFxuICAgICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKHJhd0V2ZW50LmRhdGEpIDogXG4gICAgICAgICAgICAgICAgICAgIHJhd0V2ZW50LmRhdGE7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltXZWJTb2NrZXRdIFBhcnNlIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01lc3NhZ2VQYXJzZUVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiByYXdFdmVudC5kYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbaGFuZGxlRXZlbnRdIFByb2Nlc3NpbmcgZXZlbnQ6XCIsIGV2ZW50LmV2ZW50KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlc2V0IGFjdGl2aXR5IHRpbWVyIG9uIGFueSBtZXNzYWdlIHJlY2VpdmVkXG4gICAgICAgIHRoaXMucmVzZXRBY3Rpdml0eVRpbWVyKCk7XG4gICAgICAgIFxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmV2ZW50KSB7XG4gICAgICAgICAgICBjYXNlICdwdXNoZXI6Y29ubmVjdGlvbl9lc3RhYmxpc2hlZCc6XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBldmVudC5kYXRhID09PSAnc3RyaW5nJyA/IFxuICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShldmVudC5kYXRhKSA6IFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc29ja2V0SWQgPSBkYXRhLnNvY2tldF9pZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHNlcnZlciBwcm92aWRlZCBhY3Rpdml0eSB0aW1lb3V0IGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmFjdGl2aXR5VGltZW91dCA9IGRhdGEuYWN0aXZpdHlfdGltZW91dCB8fCB0aGlzLm9wdGlvbnMuYWN0aXZpdHlUaW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRBY3Rpdml0eVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvbicsIHsgc29ja2V0SWQ6IHRoaXMuc3RhdGUuc29ja2V0SWQgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHF1ZXVlTWljcm90YXNrIHRvIGVuc3VyZSBhbnkgcGVuZGluZyBzdWJzY3JpcHRpb25zIGFyZSBwcm9jZXNzZWQgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdWJzY3JpYmUgdG8gY2hhbm5lbHMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgc3Vic2NyaWJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jaGFubmVscy5mb3JFYWNoKChjaGFubmVsLCBjaGFubmVsTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hhbm5lbC5zdWJzY3JpYmVkICYmICFjaGFubmVsLnN1YnNjcmliaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic2VuZGluZyByZXN1YnNjcmlwdGlvbiB0byBjaGFubmVsXCIsIGNoYW5uZWxOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuc3Vic2NyaWJpbmcgPSB0cnVlOyAgLy8gTWFyayBjaGFubmVsIGFzIGJlaW5nIHN1YnNjcmliZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZFN1YnNjcmlwdGlvbihjaGFubmVsTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLnN1YnNjcmliaW5nID0gZmFsc2U7ICAvLyBSZXNldCBvbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW2Nvbm5lY3Rpb25fZXN0YWJsaXNoZWRdIEZhaWxlZCB0byBzdWJzY3JpYmUgdG8gY2hhbm5lbCAke2NoYW5uZWxOYW1lfTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTdWJzY3JpcHRpb25FcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IGNoYW5uZWxOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW2Nvbm5lY3Rpb25fZXN0YWJsaXNoZWRdIFBhcnNlIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ29ubmVjdGlvbkVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdwdXNoZXI6cGluZyc6XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kKCdwdXNoZXI6cG9uZycsIHt9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAncHVzaGVyOmVycm9yJzpcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYm90aCBzdHJpbmcgYW5kIG9iamVjdCBkYXRhIGZvcm1hdHNcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGV2ZW50LmRhdGEpIDogZXZlbnQuZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3JEYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAncHVzaGVyX2ludGVybmFsOnN1YnNjcmlwdGlvbl9zdWNjZWVkZWQnOlxuICAgICAgICAgICAgICAgIGlmIChldmVudC5jaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW3N1YnNjcmlwdGlvbl9zdWNjZWVkZWRdIENoYW5uZWw6XCIsIGV2ZW50LmNoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuc3RhdGUuY2hhbm5lbHMuZ2V0KGV2ZW50LmNoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbCAmJiAhY2hhbm5lbC5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdWJzY3JpcHRpb25EYXRhID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YSAhPT0gJ3t9Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25EYXRhID0gdHlwZW9mIGV2ZW50LmRhdGEgPT09ICdzdHJpbmcnID8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKGV2ZW50LmRhdGEpIDogZXZlbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5oYW5kbGVTdWJzY3JpcHRpb25TdWNjZWVkZWQoc3Vic2NyaXB0aW9uRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbc3Vic2NyaXB0aW9uX3N1Y2NlZWRlZF0gUGFyc2UgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU3Vic2NyaXB0aW9uRXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IGV2ZW50LmNoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAncHVzaGVyOnBvbmcnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnBvbmdUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zdGF0ZS5wb25nVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBvbmdUaW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjaGFubmVsIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5jaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLnN0YXRlLmNoYW5uZWxzLmdldChldmVudC5jaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBub24tcHVzaGVyIGV2ZW50cywgcGFzcyB0aGUgZGF0YSBhcy1pcyB3aXRob3V0IGZvcmNpbmcgSlNPTiBwYXJzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBwYXJzZSBpZiBpdCdzIGEgcHVzaGVyIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudERhdGEgPSBldmVudC5ldmVudC5zdGFydHNXaXRoKCdwdXNoZXI6JykgJiYgdHlwZW9mIGV2ZW50LmRhdGEgPT09ICdzdHJpbmcnID8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGV2ZW50LmRhdGEgPyBKU09OLnBhcnNlKGV2ZW50LmRhdGEpIDogbnVsbCkgOiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5oYW5kbGVFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZXZlbnREYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbmRTdWJzY3JpcHRpb24oY2hhbm5lbE5hbWUpIHtcbiAgICAgICAgY29uc29sZS5sb2coRGF0ZS5ub3coKSwgXCIgc2VuZGluZyBzdWJzY3JpcHRpb24gdG8gY2hhbm5lbFwiLCBjaGFubmVsTmFtZSk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbkRhdGEgPSB7XG4gICAgICAgICAgICBjaGFubmVsOiBjaGFubmVsTmFtZVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFkZCBhdXRoIGRhdGEgb25seSBmb3IgcHJpdmF0ZS9wcmVzZW5jZSBjaGFubmVsc1xuICAgICAgICBpZiAoY2hhbm5lbE5hbWUuc3RhcnRzV2l0aCgncHJpdmF0ZS0nKSB8fCBjaGFubmVsTmFtZS5zdGFydHNXaXRoKCdwcmVzZW5jZS0nKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYXV0aCB8fCAhdGhpcy5vcHRpb25zLmF1dGguZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIGVuZHBvaW50IHJlcXVpcmVkIGZvciBwcml2YXRlL3ByZXNlbmNlIGNoYW5uZWxzJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGF1dGhEYXRhID0ge1xuICAgICAgICAgICAgICAgIHNvY2tldF9pZDogdGhpcy5zdGF0ZS5zb2NrZXRJZCxcbiAgICAgICAgICAgICAgICBjaGFubmVsX25hbWU6IGNoYW5uZWxOYW1lXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBNYWtlIEhUVFAgcmVxdWVzdCB0byBhdXRoIGVuZHBvaW50XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2godGhpcy5vcHRpb25zLmF1dGguZW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgIC4uLih0aGlzLm9wdGlvbnMuYXV0aC5oZWFkZXJzIHx8IHt9KVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYXV0aERhdGEpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdXRoIGVuZHBvaW50IHJldHVybmVkICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGF1dGhSZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFhdXRoUmVzcG9uc2UuYXV0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGggZW5kcG9pbnQgZGlkIG5vdCByZXR1cm4gYXV0aCBzaWduYXR1cmUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBhdXRoIHNpZ25hdHVyZSB0byBzdWJzY3JpcHRpb24gZGF0YVxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbkRhdGEuYXV0aCA9IGF1dGhSZXNwb25zZS5hdXRoO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEFkZCBhbnkgY2hhbm5lbCBkYXRhIGZvciBwcmVzZW5jZSBjaGFubmVsc1xuICAgICAgICAgICAgICAgIGlmIChhdXRoUmVzcG9uc2UuY2hhbm5lbF9kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbkRhdGEuY2hhbm5lbF9kYXRhID0gYXV0aFJlc3BvbnNlLmNoYW5uZWxfZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kKCdwdXNoZXI6c3Vic2NyaWJlJywgc3Vic2NyaXB0aW9uRGF0YSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5zdGF0ZS5jaGFubmVscy5nZXQoY2hhbm5lbE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuc3Vic2NyaWJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0F1dGhFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogY2hhbm5lbE5hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIHB1YmxpYyBjaGFubmVscywgc2VuZCBzdWJzY3JpcHRpb24gaW1tZWRpYXRlbHlcbiAgICAgICAgdGhpcy5zZW5kKCdwdXNoZXI6c3Vic2NyaWJlJywgc3Vic2NyaXB0aW9uRGF0YSk7XG4gICAgfVxuXG4gICAgc3Vic2NyaWJlKGNoYW5uZWxOYW1lKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKERhdGUubm93KCksIFwiIHN1YnNjcmliaW5nIHRvIGNoYW5uZWxcIiwgY2hhbm5lbE5hbWUpO1xuICAgICAgICBjb25zdCBleGlzdGluZ0NoYW5uZWwgPSB0aGlzLnN0YXRlLmNoYW5uZWxzLmdldChjaGFubmVsTmFtZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXR1cm4gZXhpc3RpbmcgY2hhbm5lbCBpZiBhbHJlYWR5IHN1YnNjcmliZWQgb3IgaW4gcHJvY2VzcyBvZiBzdWJzY3JpYmluZ1xuICAgICAgICBpZiAoZXhpc3RpbmdDaGFubmVsICYmIChleGlzdGluZ0NoYW5uZWwuc3Vic2NyaWJlZCB8fCBleGlzdGluZ0NoYW5uZWwuc3Vic2NyaWJpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdDaGFubmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBjaGFubmVsIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgaWYgKCFleGlzdGluZ0NoYW5uZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSBuZXcgQ2hhbm5lbChjaGFubmVsTmFtZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmNoYW5uZWxzLnNldChjaGFubmVsTmFtZSwgY2hhbm5lbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZW5kIHN1YnNjcmlwdGlvbiBpZiBjb25uZWN0ZWRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5zdGF0ZS5jaGFubmVscy5nZXQoY2hhbm5lbE5hbWUpO1xuICAgICAgICAgICAgY2hhbm5lbC5zdWJzY3JpYmluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNlbmRTdWJzY3JpcHRpb24oY2hhbm5lbE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jaGFubmVscy5nZXQoY2hhbm5lbE5hbWUpO1xuICAgIH1cblxuICAgIHVuc3Vic2NyaWJlKGNoYW5uZWxOYW1lKSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLnN0YXRlLmNoYW5uZWxzLmdldChjaGFubmVsTmFtZSk7XG4gICAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmQoJ3B1c2hlcjp1bnN1YnNjcmliZScsIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsOiBjaGFubmVsTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjaGFubmVsLnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY2hhbm5lbHMuZGVsZXRlKGNoYW5uZWxOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbmQoZXZlbnQsIGRhdGEsIGNoYW5uZWwgPSBudWxsKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIGV2ZW50IG5hbWUgbGVuZ3RoXG4gICAgICAgIGlmIChldmVudC5sZW5ndGggPiAyMDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnQgbmFtZSB0b28gbG9uZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgZGF0YSBzaXplIChtYXggMTBLQilcbiAgICAgICAgY29uc3QgZGF0YVNpemUgPSBKU09OLnN0cmluZ2lmeShkYXRhKS5sZW5ndGg7XG4gICAgICAgIGlmIChkYXRhU2l6ZSA+IDEwMjQwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IGRhdGEgdG9vIGxhcmdlJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSByYXRlIGxpbWl0aW5nIGZvciBjbGllbnQgZXZlbnRzXG4gICAgICAgIGlmIChldmVudC5zdGFydHNXaXRoKCdjbGllbnQtJykpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1JhdGVMaW1pdCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JhdGVMaW1pdEVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogNDEwMyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICBkYXRhOiBldmVudC5zdGFydHNXaXRoKCdwdXNoZXI6JykgPyBkYXRhIDogSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc29ja2V0ICYmIHRoaXMuc3RhdGUuc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldEltcGwuT1BFTikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTZW5kRXJyb3InLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIHNlbmQgbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgZXZlbnQsIGNoYW5uZWwgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhcnRBY3Rpdml0eVRpbWVyKCkge1xuICAgICAgICB0aGlzLnJlc2V0QWN0aXZpdHlUaW1lcigpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgbW9uaXRvcmluZyBmb3IgYWN0aXZpdHlcbiAgICAgICAgdGhpcy5zdGF0ZS5hY3Rpdml0eVRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5sYXN0QWN0aXZpdHkgfHwgKG5vdyAtIHRoaXMuc3RhdGUubGFzdEFjdGl2aXR5KSA+PSAodGhpcy5zdGF0ZS5hY3Rpdml0eVRpbWVvdXQgKiAxMDAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAxMDAwKTsgLy8gQ2hlY2sgZXZlcnkgc2Vjb25kXG4gICAgfVxuXG4gICAgcmVzZXRBY3Rpdml0eVRpbWVyKCkge1xuICAgICAgICB0aGlzLnN0YXRlLmxhc3RBY3Rpdml0eSA9IERhdGUubm93KCk7XG4gICAgfVxuXG4gICAgcGluZygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmNvbm5lY3RlZCkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuc2VuZCgncHVzaGVyOnBpbmcnLCB7fSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdGFydCBwb25nIHRpbWVvdXRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucG9uZ1RpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zdGF0ZS5wb25nVGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLnN0YXRlLnBvbmdUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ05vIHBvbmcgcmVjZWl2ZWQgd2l0aGluIHRpbWVvdXQsIGNsb3NpbmcgY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5wb25nVGltZW91dCAqIDEwMDApO1xuICAgIH1cblxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmFjdGl2aXR5VGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5zdGF0ZS5hY3Rpdml0eVRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuYWN0aXZpdHlUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucG9uZ1RpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zdGF0ZS5wb25nVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5wb25nVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnJlY29ubmVjdFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zdGF0ZS5yZWNvbm5lY3RUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnJlY29ubmVjdFRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTWFyayBhbGwgY2hhbm5lbHMgYXMgdW5zdWJzY3JpYmVkIG9uIGNsZWFudXBcbiAgICAgICAgdGhpcy5zdGF0ZS5jaGFubmVscy5mb3JFYWNoKGNoYW5uZWwgPT4ge1xuICAgICAgICAgICAgY2hhbm5lbC5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zdGF0ZS5zb2NrZXRJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUubGFzdEFjdGl2aXR5ID0gbnVsbDtcbiAgICB9XG5cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLnN0YXRlLnVzZXJEaXNjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHRoaXMuU1RBVEVTLkRJU0NPTk5FQ1RJTkcpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucmVjb25uZWN0VGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnN0YXRlLnJlY29ubmVjdFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUucmVjb25uZWN0VGltZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHRoaXMuU1RBVEVTLkRJU0NPTk5FQ1RFRCk7XG4gICAgfVxuXG4gICAgb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50c1tldmVudF0pIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50XS5hZGQoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb2ZmKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5ldmVudHNbZXZlbnRdKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudF0uZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVtaXQoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzW2V2ZW50XSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHNbZXZlbnRdLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soZGF0YSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmF0ZSBsaW1pdGluZyBpbXBsZW1lbnRhdGlvblxuICAgIGNoZWNrUmF0ZUxpbWl0KCkge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBvbmVTZWNvbmRBZ28gPSBub3cgLSAxMDAwO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIGV2ZW50cyBvbGRlciB0aGFuIDEgc2Vjb25kXG4gICAgICAgIHRoaXMuc3RhdGUuZXZlbnRUaW1lc3RhbXBzID0gdGhpcy5zdGF0ZS5ldmVudFRpbWVzdGFtcHMuZmlsdGVyKFxuICAgICAgICAgICAgdGltZXN0YW1wID0+IHRpbWVzdGFtcCA+IG9uZVNlY29uZEFnb1xuICAgICAgICApO1xuXG4gICAgICAgIC8vIENoZWNrIHJhdGUgbGltaXRzXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmV2ZW50VGltZXN0YW1wcy5sZW5ndGggPj0gdGhpcy5vcHRpb25zLnJhdGVMaW1pdGVyLm1heEV2ZW50c0luQnVyc3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmF0ZSBsaW1pdCBleGNlZWRlZDogVG9vIG1hbnkgZXZlbnRzIGluIGJ1cnN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBldmVudHNJbkxhc3RTZWNvbmQgPSB0aGlzLnN0YXRlLmV2ZW50VGltZXN0YW1wcy5sZW5ndGg7XG4gICAgICAgIGlmIChldmVudHNJbkxhc3RTZWNvbmQgPj0gdGhpcy5vcHRpb25zLnJhdGVMaW1pdGVyLm1heEV2ZW50c1BlclNlY29uZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSYXRlIGxpbWl0IGV4Y2VlZGVkOiBUb28gbWFueSBldmVudHMgcGVyIHNlY29uZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVjb3JkIHRoaXMgZXZlbnRcbiAgICAgICAgdGhpcy5zdGF0ZS5ldmVudFRpbWVzdGFtcHMucHVzaChub3cpO1xuICAgICAgICB0aGlzLnN0YXRlLmxhc3RFdmVudFRpbWUgPSBub3c7XG4gICAgfVxufVxuXG5jbGFzcyBDaGFubmVsIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmluZyA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgLy8gUHJlc2VuY2UgY2hhbm5lbCBzcGVjaWZpYyBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMubWVtYmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5teUlEID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IHRydWU7XG4gICAgICAgIFxuICAgICAgICAvLyBEZXRlcm1pbmUgY2hhbm5lbCB0eXBlXG4gICAgICAgIHRoaXMudHlwZSA9IHRoaXMuZ2V0Q2hhbm5lbFR5cGUoKTtcbiAgICB9XG5cbiAgICBnZXRDaGFubmVsVHlwZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubmFtZS5zdGFydHNXaXRoKCdwcml2YXRlLScpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3ByaXZhdGUnO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmFtZS5zdGFydHNXaXRoKCdwcmVzZW5jZS0nKSkge1xuICAgICAgICAgICAgcmV0dXJuICdwcmVzZW5jZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdwdWJsaWMnO1xuICAgIH1cblxuICAgIGJpbmQoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuZXZlbnRzLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5zZXQoZXZlbnROYW1lLCBuZXcgU2V0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRzLmdldChldmVudE5hbWUpLmFkZChjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgdW5iaW5kKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5nZXQoZXZlbnROYW1lKS5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5kZWxldGUoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0NoYW5uZWwgaGFuZGxlRXZlbnRdIEV2ZW50OlwiLCBldmVudCk7XG4gICAgICAgIFxuICAgICAgICAvLyBIYW5kbGUgcHJlc2VuY2UgY2hhbm5lbCBzcGVjaWZpYyBldmVudHNcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3ByZXNlbmNlJykge1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC5ldmVudCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3B1c2hlcl9pbnRlcm5hbDptZW1iZXJfYWRkZWQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVtYmVyRGF0YSA9IHR5cGVvZiBldmVudC5kYXRhID09PSAnc3RyaW5nJyA/IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UoZXZlbnQuZGF0YSkgOiBldmVudC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1iZXJzLnNldChtZW1iZXJEYXRhLnVzZXJfaWQsIG1lbWJlckRhdGEudXNlcl9pbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHVzaGVyOm1lbWJlcl9hZGRlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogbWVtYmVyRGF0YS51c2VyX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm86IG1lbWJlckRhdGEudXNlcl9pbmZvXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBjYXNlICdwdXNoZXJfaW50ZXJuYWw6bWVtYmVyX3JlbW92ZWQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVtYmVyRGF0YSA9IHR5cGVvZiBldmVudC5kYXRhID09PSAnc3RyaW5nJyA/IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UoZXZlbnQuZGF0YSkgOiBldmVudC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVtYmVyID0gdGhpcy5tZW1iZXJzLmdldChtZW1iZXJEYXRhLnVzZXJfaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1iZXJzLmRlbGV0ZShtZW1iZXJEYXRhLnVzZXJfaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHVzaGVyOm1lbWJlcl9yZW1vdmVkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogbWVtYmVyRGF0YS51c2VyX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvOiBtZW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgcmVndWxhciBldmVudHNcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmhhcyhldmVudC5ldmVudCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuZXZlbnRzLmdldChldmVudC5ldmVudCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBldmVudC5ldmVudC5zdGFydHNXaXRoKCdwdXNoZXI6JykgJiYgdHlwZW9mIGV2ZW50LmRhdGEgPT09ICdzdHJpbmcnID8gXG4gICAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UoZXZlbnQuZGF0YSkgOiBcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhkYXRhKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbQ2hhbm5lbCBoYW5kbGVFdmVudF0gUGFyc2UgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVN1YnNjcmlwdGlvblN1Y2NlZWRlZChkYXRhKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25QZW5kaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gSGFuZGxlIHByZXNlbmNlIGNoYW5uZWwgc3Vic2NyaXB0aW9uIGRhdGFcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3ByZXNlbmNlJyAmJiBkYXRhKSB7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHByZXNlbmNlIHN0YXRlXG4gICAgICAgICAgICB0aGlzLm15SUQgPSBkYXRhLm15SUQ7XG4gICAgICAgICAgICB0aGlzLm1lID0gZGF0YS5tZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgbWVtYmVyc1xuICAgICAgICAgICAgaWYgKGRhdGEucHJlc2VuY2UgJiYgZGF0YS5wcmVzZW5jZS5tZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoZGF0YS5wcmVzZW5jZS5tZW1iZXJzKS5mb3JFYWNoKChbaWQsIGluZm9dKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVtYmVycy5zZXQoaWQsIGluZm8pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW1pdCBzdWJzY3JpcHRpb24gc3VjY2VlZGVkIGV2ZW50XG4gICAgICAgIGlmICh0aGlzLmV2ZW50cy5oYXMoJ3B1c2hlcjpzdWJzY3JpcHRpb25fc3VjY2VlZGVkJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuZXZlbnRzLmdldCgncHVzaGVyOnN1YnNjcmlwdGlvbl9zdWNjZWVkZWQnKTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGRhdGEpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVN1YnNjcmlwdGlvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmliaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmhhcygncHVzaGVyOnN1YnNjcmlwdGlvbl9lcnJvcicpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjpzdWJzY3JpcHRpb25fZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcmVzZW5jZSBjaGFubmVsIHNwZWNpZmljIG1ldGhvZHNcbiAgICBtZW1iZXJzKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAncHJlc2VuY2UnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lbWJlcnMgY2FuIG9ubHkgYmUgYWNjZXNzZWQgb24gcHJlc2VuY2UgY2hhbm5lbHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLm1lbWJlcnMuZW50cmllcygpKS5tYXAoKFtpZCwgaW5mb10pID0+ICh7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGluZm9cbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIG15TWVtYmVyKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAncHJlc2VuY2UnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lbWJlciBpbmZvIGNhbiBvbmx5IGJlIGFjY2Vzc2VkIG9uIHByZXNlbmNlIGNoYW5uZWxzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWUgPyB7IGlkOiB0aGlzLm15SUQsIGluZm86IHRoaXMubWUgfSA6IG51bGw7XG4gICAgfVxuXG4gICAgZW1pdChldmVudE5hbWUsIGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmV2ZW50cy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGRhdGEpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRyaWdnZXIoZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5uYW1lLnN0YXJ0c1dpdGgoJ3ByaXZhdGUtJykgJiYgIXRoaXMubmFtZS5zdGFydHNXaXRoKCdwcmVzZW5jZS0nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQgZXZlbnRzIGNhbiBvbmx5IGJlIHRyaWdnZXJlZCBvbiBwcml2YXRlIG9yIHByZXNlbmNlIGNoYW5uZWxzJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV2ZW50TmFtZS5zdGFydHNXaXRoKCdjbGllbnQtJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50IGV2ZW50cyBtdXN0IGJlIHByZWZpeGVkIHdpdGggY2xpZW50LScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgZXZlbnQgbmFtZSBmb3JtYXRcbiAgICAgICAgaWYgKCEvXmNsaWVudC1bYS16QS1aMC05LV9dKyQvLnRlc3QoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGV2ZW50IG5hbWUgZm9ybWF0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsaWVudC5zZW5kKGV2ZW50TmFtZSwgZGF0YSwgdGhpcy5uYW1lKTtcbiAgICB9XG59XG5cbi8vIEV4cG9ydCBmb3IgYm90aCBicm93c2VyIGFuZCBOb2RlLmpzIGVudmlyb25tZW50c1xuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBKZXRTb2NrZXQ7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LkpldFNvY2tldCA9IEpldFNvY2tldDtcbn0gIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL0pldFNvY2tldC5qc1wiKTtcbiIsIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==