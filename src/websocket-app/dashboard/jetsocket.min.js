!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.Jetsocket=t():e.Jetsocket=t()}(this,(function(){return e={591:function(e){"use strict";e.exports=function(){throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object")}},290:function(e,t,s){const n="undefined"!=typeof WebSocket?WebSocket:s(591);class i{constructor(e){this.version="1.0.0",this.protocol=7,this.STATES={INITIALIZED:"initialized",CONNECTING:"connecting",CONNECTED:"connected",DISCONNECTING:"disconnecting",DISCONNECTED:"disconnected",RECONNECTING:"reconnecting",FAILED:"failed"},this.options={appKey:e.appKey,cluster:e.cluster||"mt1",encrypted:!1!==e.encrypted,wsHost:e.wsHost||`ws-${e.cluster}.jetsocket.io`,wsPort:e.wsPort||(e.encrypted?443:80),activityTimeout:120,pongTimeout:30,maxReconnectionAttempts:6,maxReconnectGap:3e4,minReconnectGap:1e3,rateLimiter:{maxEventsPerSecond:10,maxEventsInBurst:100},...e},this.state={connectionState:this.STATES.INITIALIZED,socket:null,channels:new Map,socketId:null,activityTimeout:this.options.activityTimeout,lastActivity:null,activityTimer:null,pongTimer:null,reconnectTimer:null,reconnectionAttempts:0,userDisconnected:!1,eventCount:0,eventTimestamps:[],lastEventTime:null},this.events={state_change:new Set,connection:new Set,error:new Set,disconnection:new Set},this.ERROR_CODES={4e3:"Application only accepts SSL connections",4001:"Application does not exist",4002:"Application disabled",4003:"Application rate limited",4004:"Path not found",4005:"Invalid version string format",4006:"Invalid version",4007:"Unsupported protocol version",4008:"No protocol version supplied",4009:"Connection is unauthorized",4100:"Over connection limit",4101:"Over connection limit for application",4102:"Path already in use",4103:"Client event rejected - rate limit exceeded",4104:"Client event rejected - invalid data format",4105:"Client event rejected - event name too long",4106:"Client event rejected - event data too large",4107:"Client event rejected - event name format invalid",4200:"Generic subscription error",4201:"Not authorized to subscribe",4202:"Subscription rejected - rate limit exceeded",4203:"Subscription rejected - invalid channel name",4204:"Subscription rejected - channel already subscribed",4205:"Subscription rejected - channel capacity reached",4206:"Subscription rejected - presence channel limit reached",4207:"Subscription rejected - presence channel user limit reached"},this.connect()}updateState(e,t={}){const s=this.state.connectionState;this.state.connectionState=e,this.emit("state_change",{previous:s,current:e,...t})}connect(){if(this.state.userDisconnected)return;this.updateState(this.STATES.CONNECTING);const e=this.options.encrypted?"wss://":"ws://",t=new URLSearchParams({protocol:this.protocol,client:"js",version:this.version}).toString(),s=`${e}${this.options.wsHost}/app/${this.options.appKey}?${t}`;try{this.state.socket=new n(s),this.bindSocketEvents()}catch(e){this.handleError({type:"WebSocketError",error:e,data:{url:s}})}}handleError(e){let t={type:e.type||"Error",code:e.code,message:e.message||"Unknown error"};if(e.code&&this.ERROR_CODES[e.code]&&(t.description=this.ERROR_CODES[e.code]),e.data&&(t.data=e.data),this.emit("error",t),"WebSocketError"!==e.type&&"ConnectionError"!==e.type||(this.updateState(this.STATES.FAILED,{error:t}),this.scheduleReconnection()),"SubscriptionError"===e.type&&e.channel){const t=this.state.channels.get(e.channel);t&&t.handleSubscriptionError(e)}}scheduleReconnection(){if(this.state.reconnectTimer&&clearTimeout(this.state.reconnectTimer),this.state.userDisconnected||this.state.reconnectionAttempts>=this.options.maxReconnectionAttempts)return void this.updateState(this.STATES.FAILED);const e=Math.min(this.options.maxReconnectGap,Math.max(this.options.minReconnectGap,1e3*Math.pow(2,this.state.reconnectionAttempts)));this.updateState(this.STATES.RECONNECTING,{attempt:this.state.reconnectionAttempts+1,delay:e}),this.state.reconnectTimer=setTimeout((()=>{this.state.reconnectionAttempts++,this.connect()}),e)}bindSocketEvents(){this.state.socket.onopen=()=>{this.state.reconnectionAttempts=0},this.state.socket.onclose=e=>{this.cleanup(),this.emit("disconnection",e),this.state.userDisconnected?this.updateState(this.STATES.DISCONNECTED):this.scheduleReconnection()},this.state.socket.onerror=e=>{this.handleError(e)},this.state.socket.onmessage=e=>{try{const t="string"==typeof e.data?JSON.parse(e.data):e.data;this.handleEvent(t)}catch(t){console.error("[WebSocket] Parse error:",t),this.emit("error",{type:"MessageParseError",error:t,data:e.data})}}}handleEvent(e){switch(console.log("[handleEvent] Processing event:",e.event),this.resetActivityTimer(),e.event){case"pusher:connection_established":try{const t="string"==typeof e.data?JSON.parse(e.data):e.data;this.state.socketId=t.socket_id,this.state.activityTimeout=t.activity_timeout||this.options.activityTimeout,this.state.connected=!0,this.startActivityTimer(),this.emit("connection",{socketId:this.state.socketId}),queueMicrotask((()=>{this.state.channels.forEach(((e,t)=>{if(!e.subscribed&&!e.subscribing){console.log("sending resubscription to channel",t);try{e.subscribing=!0,this.sendSubscription(t)}catch(s){e.subscribing=!1,console.error(`[connection_established] Failed to subscribe to channel ${t}:`,s),this.emit("error",{type:"SubscriptionError",error:s,channel:t})}}}))}))}catch(t){console.error("[connection_established] Parse error:",t),this.emit("error",{type:"ConnectionError",error:t,data:e.data})}break;case"pusher:ping":this.send("pusher:pong",{});break;case"pusher:error":const t="string"==typeof e.data?JSON.parse(e.data):e.data;this.emit("error",t);break;case"pusher_internal:subscription_succeeded":if(e.channel){console.log("[subscription_succeeded] Channel:",e.channel);const t=this.state.channels.get(e.channel);if(t&&!t.subscribed)try{let s={};e.data&&"{}"!==e.data&&(s="string"==typeof e.data?JSON.parse(e.data):e.data),t.handleSubscriptionSucceeded(s)}catch(t){console.error("[subscription_succeeded] Parse error:",t),this.emit("error",{type:"SubscriptionError",error:t,channel:e.channel})}}break;case"pusher:pong":this.state.pongTimer&&(clearTimeout(this.state.pongTimer),this.state.pongTimer=null);break;default:if(e.channel){const t=this.state.channels.get(e.channel);if(t){const s=e.event.startsWith("pusher:")&&"string"==typeof e.data?e.data?JSON.parse(e.data):null:e.data;t.handleEvent({...e,data:s})}}}}sendSubscription(e){console.log(Date.now()," sending subscription to channel",e);const t={channel:e};if(e.startsWith("private-")||e.startsWith("presence-")){if(!this.options.auth||!this.options.auth.endpoint)throw new Error("Authentication endpoint required for private/presence channels");const s={socket_id:this.state.socketId,channel_name:e};return fetch(this.options.auth.endpoint,{method:"POST",headers:{"Content-Type":"application/json",...this.options.auth.headers||{}},body:JSON.stringify(s)}).then((e=>{if(!e.ok)throw new Error(`Auth endpoint returned ${e.status}`);return e.json()})).then((e=>{if(!e.auth)throw new Error("Auth endpoint did not return auth signature");t.auth=e.auth,e.channel_data&&(t.channel_data=e.channel_data),this.send("pusher:subscribe",t)})).catch((t=>{const s=this.state.channels.get(e);s&&(s.subscribing=!1),this.emit("error",{type:"AuthError",error:t,channel:e})}))}this.send("pusher:subscribe",t)}subscribe(e){console.log(Date.now()," subscribing to channel",e);const t=this.state.channels.get(e);if(t&&(t.subscribed||t.subscribing))return t;if(!t){const t=new r(e,this);this.state.channels.set(e,t)}return this.state.connected&&(this.state.channels.get(e).subscribing=!0,this.sendSubscription(e)),this.state.channels.get(e)}unsubscribe(e){const t=this.state.channels.get(e);t&&(this.send("pusher:unsubscribe",{channel:e}),t.subscribed=!1,this.state.channels.delete(e))}send(e,t,s=null){if(e.length>200)throw new Error("Event name too long");if(JSON.stringify(t).length>10240)throw new Error("Event data too large");if(e.startsWith("client-"))try{this.checkRateLimit()}catch(e){return void this.handleError({type:"RateLimitError",code:4103,message:e.message})}const i={event:e,data:e.startsWith("pusher:")?t:JSON.stringify(t)};if(s&&(i.channel=s),this.state.socket&&this.state.socket.readyState===n.OPEN)try{this.state.socket.send(JSON.stringify(i))}catch(t){this.handleError({type:"SendError",message:"Failed to send message",data:{event:e,channel:s}})}}startActivityTimer(){this.resetActivityTimer(),this.state.activityTimer=setInterval((()=>{const e=Date.now();(!this.state.lastActivity||e-this.state.lastActivity>=1e3*this.state.activityTimeout)&&this.ping()}),1e3)}resetActivityTimer(){this.state.lastActivity=Date.now()}ping(){this.state.connected&&(this.send("pusher:ping",{}),this.state.pongTimer&&clearTimeout(this.state.pongTimer),this.state.pongTimer=setTimeout((()=>{console.log("No pong received within timeout, closing connection"),this.disconnect()}),1e3*this.options.pongTimeout))}cleanup(){this.state.activityTimer&&(clearInterval(this.state.activityTimer),this.state.activityTimer=null),this.state.pongTimer&&(clearTimeout(this.state.pongTimer),this.state.pongTimer=null),this.state.reconnectTimer&&(clearTimeout(this.state.reconnectTimer),this.state.reconnectTimer=null),this.state.channels.forEach((e=>{e.subscribed=!1})),this.state.socketId=null,this.state.lastActivity=null}disconnect(){this.state.userDisconnected=!0,this.updateState(this.STATES.DISCONNECTING),this.state.reconnectTimer&&(clearTimeout(this.state.reconnectTimer),this.state.reconnectTimer=null),this.state.socket&&this.state.socket.close(),this.cleanup(),this.updateState(this.STATES.DISCONNECTED)}on(e,t){this.events[e]&&this.events[e].add(t)}off(e,t){this.events[e]&&this.events[e].delete(t)}emit(e,t){this.events[e]&&this.events[e].forEach((e=>e(t)))}checkRateLimit(){const e=Date.now(),t=e-1e3;if(this.state.eventTimestamps=this.state.eventTimestamps.filter((e=>e>t)),this.state.eventTimestamps.length>=this.options.rateLimiter.maxEventsInBurst)throw new Error("Rate limit exceeded: Too many events in burst");if(this.state.eventTimestamps.length>=this.options.rateLimiter.maxEventsPerSecond)throw new Error("Rate limit exceeded: Too many events per second");this.state.eventTimestamps.push(e),this.state.lastEventTime=e}}class r{constructor(e,t){this.name=e,this.client=t,this.events=new Map,this.subscribed=!1,this.subscribing=!1,this.members=new Map,this.myID=null,this.me=null,this.subscriptionPending=!0,this.type=this.getChannelType()}getChannelType(){return this.name.startsWith("private-")?"private":this.name.startsWith("presence-")?"presence":"public"}bind(e,t){this.events.has(e)||this.events.set(e,new Set),this.events.get(e).add(t)}unbind(e,t){this.events.has(e)&&(t?this.events.get(e).delete(t):this.events.delete(e))}handleEvent(e){if(console.log("[Channel handleEvent] Event:",e),"presence"===this.type)switch(e.event){case"pusher_internal:member_added":if(e.data){const t="string"==typeof e.data?JSON.parse(e.data):e.data;this.members.set(t.user_id,t.user_info),this.emit("pusher:member_added",{id:t.user_id,info:t.user_info})}return;case"pusher_internal:member_removed":if(e.data){const t="string"==typeof e.data?JSON.parse(e.data):e.data,s=this.members.get(t.user_id);this.members.delete(t.user_id),s&&this.emit("pusher:member_removed",{id:t.user_id,info:s})}return}if(this.events.has(e.event)){const t=this.events.get(e.event);try{const s=e.event.startsWith("pusher:")&&"string"==typeof e.data?JSON.parse(e.data):e.data;t.forEach((e=>e(s)))}catch(e){throw console.error("[Channel handleEvent] Parse error:",e),e}}}handleSubscriptionSucceeded(e){this.subscribed=!0,this.subscribing=!1,this.subscriptionPending=!1,"presence"===this.type&&e&&(this.myID=e.myID,this.me=e.me,e.presence&&e.presence.members&&Object.entries(e.presence.members).forEach((([e,t])=>{this.members.set(e,t)}))),this.events.has("pusher:subscription_succeeded")&&this.events.get("pusher:subscription_succeeded").forEach((t=>t(e)))}handleSubscriptionError(e){this.subscribed=!1,this.subscribing=!1,this.subscriptionPending=!1,this.events.has("pusher:subscription_error")&&this.emit("pusher:subscription_error",e)}members(){if("presence"!==this.type)throw new Error("Members can only be accessed on presence channels");return Array.from(this.members.entries()).map((([e,t])=>({id:e,info:t})))}myMember(){if("presence"!==this.type)throw new Error("Member info can only be accessed on presence channels");return this.me?{id:this.myID,info:this.me}:null}emit(e,t){this.events.has(e)&&this.events.get(e).forEach((e=>e(t)))}trigger(e,t){if(!this.name.startsWith("private-")&&!this.name.startsWith("presence-"))throw new Error("Client events can only be triggered on private or presence channels");if(!e.startsWith("client-"))throw new Error("Client events must be prefixed with client-");if(!/^client-[a-zA-Z0-9-_]+$/.test(e))throw new Error("Invalid event name format");this.client.send(e,t,this.name)}}e.exports?e.exports=i:"undefined"!=typeof window&&(window.Jetsocket=i)}},t={},function s(n){var i=t[n];if(void 0!==i)return i.exports;var r=t[n]={exports:{}};return e[n](r,r.exports,s),r.exports}(290);var e,t}));
//# sourceMappingURL=jetsocket.min.js.map